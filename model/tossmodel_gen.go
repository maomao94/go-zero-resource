// Code generated by goctl. DO NOT EDIT!

package model

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/Masterminds/squirrel"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	tOssFieldNames          = builder.RawFieldNames(&TOss{})
	tOssRows                = strings.Join(tOssFieldNames, ",")
	tOssRowsExpectAutoSet   = strings.Join(stringx.Remove(tOssFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`"), ",")
	tOssRowsWithPlaceHolder = strings.Join(stringx.Remove(tOssFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`"), "=?,") + "=?"

	cacheTOssIdPrefix              = "cache:tOss:id:"
	cacheTOssTenantIdOssCodePrefix = "cache:tOss:tenantId:ossCode:"
)

type (
	tOssModel interface {
		Insert(ctx context.Context, data *TOss) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*TOss, error)
		FindOneByTenantIdOssCode(ctx context.Context, tenantId string, ossCode string) (*TOss, error)
		Update(ctx context.Context, data *TOss) error
		Delete(ctx context.Context, id int64) error
		RowBuilder() squirrel.SelectBuilder
		CountBuilder(field string) squirrel.SelectBuilder
		SumBuilder(field string) squirrel.SelectBuilder
		FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder) (float64, error)
		FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder) (int64, error)
		FindPageListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy string) ([]*TOss, error)
	}

	defaultTOssModel struct {
		sqlc.CachedConn
		table string
	}

	TOss struct {
		Id         int64     `db:"id"`
		CreateTime time.Time `db:"create_time"`
		UpdateTime time.Time `db:"update_time"`
		DeleteTime time.Time `db:"delete_time"`
		DelState   int64     `db:"del_state"`
		Version    int64     `db:"version"`     // 乐观锁版本号
		TenantId   string    `db:"tenant_id"`   // 租户ID
		Category   int64     `db:"category"`    // 分类
		OssCode    string    `db:"oss_code"`    // 资源编号
		Endpoint   string    `db:"endpoint"`    // 资源地址
		AccessKey  string    `db:"access_key"`  // accessKey
		SecretKey  string    `db:"secret_key"`  // secretKey
		BucketName string    `db:"bucket_name"` // 空间名
		AppId      string    `db:"app_id"`      // 应用ID
		Region     string    `db:"region"`      // 地域简称
		Remark     string    `db:"remark"`      // 备注
		Status     int64     `db:"status"`      // 状态
	}
)

func newTOssModel(conn sqlx.SqlConn, c cache.CacheConf) *defaultTOssModel {
	return &defaultTOssModel{
		CachedConn: sqlc.NewConn(conn, c),
		table:      "`t_oss`",
	}
}

func (m *defaultTOssModel) Delete(ctx context.Context, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	tOssIdKey := fmt.Sprintf("%s%v", cacheTOssIdPrefix, id)
	tOssTenantIdOssCodeKey := fmt.Sprintf("%s%v:%v", cacheTOssTenantIdOssCodePrefix, data.TenantId, data.OssCode)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, tOssIdKey, tOssTenantIdOssCodeKey)
	return err
}

func (m *defaultTOssModel) FindOne(ctx context.Context, id int64) (*TOss, error) {
	tOssIdKey := fmt.Sprintf("%s%v", cacheTOssIdPrefix, id)
	var resp TOss
	err := m.QueryRowCtx(ctx, &resp, tOssIdKey, func(ctx context.Context, conn sqlx.SqlConn, v interface{}) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", tOssRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultTOssModel) FindOneByTenantIdOssCode(ctx context.Context, tenantId string, ossCode string) (*TOss, error) {
	tOssTenantIdOssCodeKey := fmt.Sprintf("%s%v:%v", cacheTOssTenantIdOssCodePrefix, tenantId, ossCode)
	var resp TOss
	err := m.QueryRowIndexCtx(ctx, &resp, tOssTenantIdOssCodeKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v interface{}) (i interface{}, e error) {
		query := fmt.Sprintf("select %s from %s where `tenant_id` = ? and `oss_code` = ? limit 1", tOssRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, tenantId, ossCode); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultTOssModel) Insert(ctx context.Context, data *TOss) (sql.Result, error) {
	tOssIdKey := fmt.Sprintf("%s%v", cacheTOssIdPrefix, data.Id)
	tOssTenantIdOssCodeKey := fmt.Sprintf("%s%v:%v", cacheTOssTenantIdOssCodePrefix, data.TenantId, data.OssCode)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, tOssRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.DeleteTime, data.DelState, data.Version, data.TenantId, data.Category, data.OssCode, data.Endpoint, data.AccessKey, data.SecretKey, data.BucketName, data.AppId, data.Region, data.Remark, data.Status)
	}, tOssIdKey, tOssTenantIdOssCodeKey)
	return ret, err
}

func (m *defaultTOssModel) Update(ctx context.Context, newData *TOss) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	tOssIdKey := fmt.Sprintf("%s%v", cacheTOssIdPrefix, data.Id)
	tOssTenantIdOssCodeKey := fmt.Sprintf("%s%v:%v", cacheTOssTenantIdOssCodePrefix, data.TenantId, data.OssCode)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, tOssRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.DeleteTime, newData.DelState, newData.Version, newData.TenantId, newData.Category, newData.OssCode, newData.Endpoint, newData.AccessKey, newData.SecretKey, newData.BucketName, newData.AppId, newData.Region, newData.Remark, newData.Status, newData.Id)
	}, tOssIdKey, tOssTenantIdOssCodeKey)
	return err
}

func (m *defaultTOssModel) formatPrimary(primary interface{}) string {
	return fmt.Sprintf("%s%v", cacheTOssIdPrefix, primary)
}

func (m *defaultTOssModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary interface{}) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", tOssRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultTOssModel) tableName() string {
	return m.table
}

func (m *defaultTOssModel) RowBuilder() squirrel.SelectBuilder {
	return squirrel.Select(tOssRows).From(m.table)
}

func (m *defaultTOssModel) CountBuilder(field string) squirrel.SelectBuilder {
	return squirrel.Select("COUNT(" + field + ")").From(m.table)
}

func (m *defaultTOssModel) SumBuilder(field string) squirrel.SelectBuilder {
	return squirrel.Select("IFNULL(SUM(" + field + "),0)").From(m.table)
}

func (m *defaultTOssModel) FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder) (float64, error) {
	query, values, err := sumBuilder.Where("del_state = ?", DelStateNo).ToSql()
	if err != nil {
		return 0, err
	}
	var resp float64
	err = m.QueryRowNoCacheCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultTOssModel) FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder) (int64, error) {
	query, values, err := countBuilder.Where("del_state = ?", DelStateNo).ToSql()
	if err != nil {
		return 0, err
	}
	var resp int64
	err = m.QueryRowNoCacheCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultTOssModel) FindPageListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy string) ([]*TOss, error) {
	if orderBy == "" {
		rowBuilder = rowBuilder.OrderBy("id DESC")
	} else {
		rowBuilder = rowBuilder.OrderBy(orderBy)
	}
	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	query, values, err := rowBuilder.Where("del_state = ?", DelStateNo).Offset(uint64(offset)).Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*TOss
	err = m.QueryRowsNoCacheCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}
